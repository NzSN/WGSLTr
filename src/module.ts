import { Vertex, VertexState } from "./base/graph";
import { Tree, Node } from "web-tree-sitter";

let mod_counter = 0;

function uniqueID(): string {
    const id = mod_counter.toString();
    ++mod_counter;
    return id;
}


export type Symbol  = string;
type ModID   = string;
type ModPath = string;
export class Module implements Vertex {
    public state: VertexState = VertexState.UNDISCOVERED;

    public static overrides: Map<ModPath, Symbol[]> = new Map();
    public static override_list: Symbol[] = [];

    public static all: Map<ModPath, Module> = new Map();
    public static all_by_id: Map<ModID, Module> = new Map();

    private _circular_point: Module[] = [];

    // Autogenerated global unique identifier for each Module.
    private _ident: ModID;

    private _path: string;
    private _tree: Tree;
    private _deps: Module[]   = [];
    private _depBys: Module[] = [];

    private _maybe_external_symbol_list: Symbol[] | null = null;
    private _external_symbols: Map<ModID,Symbol[]> = new Map();

    // Global Symbols
    private _func_symbols: Symbol[] = [];
    private _var_symbols: Symbol[] = [];
    private _type_symbols: Symbol[] = [];

    public get circular_point() {
        return this._circular_point;
    }

    public addCircularPoint(mod: Module) {
        this._circular_point.push(mod);
    }

    public get func_syms(): Symbol[] {
        return this._func_symbols;
    }

    public addFuncSym(s: Symbol) {
        this._func_symbols.push(s);
    }

    public get var_syms(): Symbol[] {
        return this._var_symbols;
    }

    public addVarSym(s: Symbol) {
        this._var_symbols.push(s);
    }

    public get type_syms(): Symbol[] {
        return this._type_symbols;
    }

    public addTypeSym(s: Symbol) {
        this._type_symbols.push(s);
    }

    public get edges() {
        return this._deps;
    }

    public get tree() {
        return this._tree;
    }

    constructor(path: ModPath, tree: Tree) {
        this._path = path;
        this._tree = tree;
        this._ident = uniqueID();

        Module.all.set(path, this);
        Module.all_by_id.set(this._ident, this);
    }

    public setExternalSymbols(id: ModID, symbols: Symbol[]) {
        this._external_symbols.set(id, symbols);
        this._maybe_external_symbol_list = null;
    }

    public getExternalSymbols(id: ModID): Symbol[] | undefined {
        return this._external_symbols.get(id);
    }

    public get allExternalSymbols() {
        if (this._maybe_external_symbol_list == null) {
            this._maybe_external_symbol_list =
                Array.from(this._external_symbols.values()).reduce(
                    (acc,cur) => {
                        return acc.concat(cur);
                    },
                    []);
        }
        return this._maybe_external_symbol_list;
    }

    public get ident() {
        return this._ident;
    }

    public get rootNode(): Node {
        return this._tree.rootNode;
    }

    public isDepOn(may_dep: Module) {
        return this._deps.find((m: Module) => {
            return may_dep.path == m.path;
        }) != undefined;
    }

    public isDepBy(may_dep_by: Module) {
        return may_dep_by.isDepOn(this);
    }

    public dep(m: Module) {
        this._deps.push(m);
    }

    public depBy(m: Module) {
        this._depBys.push(m);
    }

    public get path() {
        return this._path;
    }

    public isExternalSymbol(sym: Symbol) {
        return this.allExternalSymbols.find(
            (s) => s == sym) != undefined;
    }

    public symbolFrom(sym: Symbol): ModID | null {
        let maybe_mod_id =
            Array.from(this._external_symbols.keys()).find((key) => {
                return (this._external_symbols.get(key) as string[])
                    .find((s) => s == sym) != undefined; });
        if (maybe_mod_id == undefined) {
            return null;
        } else {
            return maybe_mod_id;
        }
    }
}
